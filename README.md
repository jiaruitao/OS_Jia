#### 1. 让 MBR先飞一会儿

mbr.S 加载到 0x7c00 处执行，清屏，移动光标，打印字符串 蓝底白字的“OS_Jia”。

#### 2. 改进MBR ,直接操作显卡

mbr.S 加载到 0x7c00 处执行，清屏，直接往显存放入要显示的字符及属性，打印输出 蓝底红字的“OS_Jia”。

#### 3. 改进MBR, 读硬盘

mbr.S 添加读硬盘的函数，把第二扇区里的loader读到0x9000处，最后跳转至0x9000处执行。

添加 loader.S 生成loader.bin 下载到硬盘的第二扇区。

#### 4. 改进loader.S 进入保护模式

在 loader.S 中构建 GDT ，然后分3步进入保护模式：

- 打开 A20 地址线
- 加载 GDTR 寄存器
- cr0 寄存器的第 0 位置 1。

#### 5. 获取物理内存容量

在进入保护模式之前，利用 BIOS 中断来获取物理内存容量，并放在 loader的第 0x203地址处（loader要加载到 0x900 处，所以最终内存容量的数值放在 0xb03 内存地址处）。（通过 xp 0xb03 查看）

#### 6. 启用分页机制

创建页目录表和页表，页目录表地址赋给cr3, 打开cr0的pg 位，开启分页机制。（要修改GDT中的内容和栈指针）

#### 7. 加载内核

编写 main.c ，用gcc 编译、ld 链接 为 elf 格式的文件（kernel.bin）。

把内核kernel.bin从9扇区读到物理地址0x7000处, 然后解析elf格式文件，加载到0xc0001500，栈顶改为0xc009fc00。

最终跳转到内核（0xc0001500）执行。

#### 8. 实现打印字符

添加print.S 和 std_int.h ，在main.c 中调用 put_char 实现打印单个字符。

#### 9. 实现打印字符串

利用put_char，封装一个put_str函数实现打印字符串。

#### 10. 实现打印整数

利用put_char，继续封装函数put_int 实现打印16进制整数。

#### 11. 编写中断处理程序

构建IDT（中断描述符表）、初始化8259A、加载 idtr 寄存器，打开中断。

#### 12. 调整中断处理程序

从汇编跳到c程序执行中断处理。

#### 13. 实现 ASSERT 断言

添加文件debug.h 和 debug.c 实现 ASSERT。